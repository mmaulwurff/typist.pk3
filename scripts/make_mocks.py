#!/usr/bin/python3

"""This script makes mock implementation for ZScript interfaces classes.
In this project, a class is considered an interface if it is marked as
'abstract'."""

import re
from pathlib import Path


def tokenize(filename):
    """This function reads a file and converts it to a list of tokens."""

    src = open(filename, 'r')
    contents = src.read()

    # remove single-line comments
    contents = re.sub('//.*', '', contents)

    # remove multi-line comments
    contents = contents.replace('\n', '')

    contents = re.sub(r'\/\*.*?\*\/', '', contents)

    # remove strings
    contents = re.sub('\".*\"', '', contents)

    # tokenize
    contents = re.split(r'([ {};()])', contents)

    # remove empty elements
    contents = list(filter(lambda a: a != '', contents))
    contents = list(filter(lambda a: a != ' ', contents))

    return contents


def is_interface(token_list):
    """This function checks if a class represented by a token list is an interface."""

    return 'abstract' in token_list


def get_class_name(token_list):
    """This function returns a class name for a class represented by a token list."""

    return token_list[1]


def make_mock_name(name):
    """This function generates a mock class name by the class name."""

    return name + "Mock"


def generate_mock_class(tokens):
    """This class generates a mock class for the class represented by a token list.
    Mock class contains:
    - an implementation for interface methods;
    - Expect_... function for setting expected function call result;
    - bool isSatisfied_...() function to check if the expected number of calls is done.
    """

    # generate a header
    class_name = get_class_name(tokens)
    mock_name = make_mock_name(class_name)
    out = 'class ' + mock_name + ' : ' + class_name + '\n{\n\n'

    # generate methods
    for i, token in enumerate(tokens):
        if token == 'abstract':
            return_type = tokens[i + 3]
            func_name = tokens[i + 4]
            is_void = return_type == 'void'

            # implementation for the interface
            mock_attribute = '_mock_' + func_name
            mock_attribute_expected = mock_attribute + '_expected'
            mock_attribute_called = mock_attribute + '_called'

            out += '  override\n  ' + return_type + ' ' + func_name + '('
            args_index = i + 6
            pairs = []
            while tokens[args_index] != ')':
                pairs.append(tokens[args_index] + ' ' + tokens[args_index + 1])
                args_index += 2

            out += ' '.join(pairs)
            out += ')\n'

            out += '  {\n'
            out += '    ++' + mock_attribute_called + ';\n'
            if not is_void:
                out += '    return ' + mock_attribute + ';\n'
            out += '  }\n\n'

            # setter for mock attribute
            setter_name = 'Expect_' + func_name
            out += '  void ' + setter_name + '('
            if not is_void:
                out += return_type + ' value, '
            out += 'int expected = 1)\n'
            out += '  {\n'
            if not is_void:
                out += '    ' + mock_attribute + ' = value;\n'
            out += '    ' + mock_attribute_expected + ' = expected;\n'
            out += '    ' + mock_attribute_called+ ' = 0;\n'
            out += '  }\n\n'

            # isSatisfied
            out += '  bool isSatisfied_' + func_name + '() const\n'
            out += '  {\n'
            out += '    return ' + mock_attribute_expected + ' == ' + mock_attribute_called + ';\n'
            out += '  }\n\n'

            # mock attributes
            if not is_void:
                out += '  private ' + return_type + ' ' + mock_attribute + ';\n'
            out += '  private int ' + mock_attribute_expected + ';\n'
            out += '  private int ' + mock_attribute_called + ';\n\n'

    # generate a footer
    out += '} // class ' + mock_name + '\n\n'

    return out


if __name__ == "__main__":

    HEADER_FILE = open('docs/source-template.zst', 'r')
    MOCK_CONTENTS = HEADER_FILE.read() + '\n'

    MOCK_CONTENTS += "// This file is generated by ./scripts/make_mocks.py.\n"
    MOCK_CONTENTS += "// Do not edit it by hand, your changes will be overwritten!\n\n"

    SOURCES = list(Path("./zscript/typist").rglob("*.zs"))

    #SOURCES = [
    #    'zscript/typist/view/tt_View.zs',
    #]

    for source in SOURCES:
        source_tokens = tokenize(source)
        if is_interface(source_tokens):
            MOCK_CONTENTS += generate_mock_class(source_tokens)

    OUT_FILE = open('zscript/typist/tests/mocks.zs', 'w')
    OUT_FILE.write(MOCK_CONTENTS)
    #print(MOCK_CONTENTS)
